---
title: "unequal prob swlb vs dowlb"
author: "Ujjayini Das"
date: "2025-12-01"
output: html_document
---
```{r}
############################################################
## Unequal-probability single-stage design:
## D-OWLB vs S-WLB (using your current code style)
############################################################

library(MASS)       # polr
library(parallel)
library(doParallel)
library(foreach)

set.seed(2026)

############################################################
# 0. Disparity functional and helper (same as your code)
############################################################

apouey_disparity = function(cumprobs, gamma = 0.73, C = 2^gamma) {
  1 - (C / length(cumprobs)) * sum(abs(cumprobs - 0.5)^gamma)
}

disparity_from_fit = function(fit, data,
                              group_var = "SES",
                              y_var = "Y",
                              gamma = 0.73) {
  K = length(levels(data[[y_var]]))
  groups = sort(unique(data[[group_var]]))
  Dg = setNames(numeric(length(groups)), groups)

  for (g in groups) {
    newdat = data
    newdat[[group_var]] = factor(g, levels = levels(data[[group_var]]))
    p_cat = predict(fit, newdata = newdat, type = "probs")
    p_bar = colMeans(p_cat)
    cumprobs = cumsum(p_bar)[1:(K - 1)]
    Dg[g] = apouey_disparity(cumprobs, gamma = gamma)
  }
  Dg
}

############################################################
# 1. Population generator (reuse your gen_population)
############################################################

gen_population = function(N_pop = 1e5,
                           H = 4,
                           mean_psu_size = 50,
                           K = 5,
                           sigma_u = 3) {

  stratum = sample(1:H, N_pop, replace = TRUE)
  psu = integer(N_pop)
  id  = seq_len(N_pop)

  tab_h = table(stratum)
  J_h_target = as.numeric(tab_h) / mean_psu_size
  names(J_h_target) = names(tab_h)
  J_h = pmax(2L, round(J_h_target))
  names(J_h) = names(tab_h)

  for (h_char in names(tab_h)) {
    h = as.integer(h_char)
    idx_h = which(stratum == h)
    nh = length(idx_h)
    if (nh == 0) next

    J_hh = J_h[h_char]
    if (!is.finite(J_hh) || J_hh < 2) J_hh = 2L
    J_hh = as.integer(J_hh)

    psu[idx_h] = sample.int(J_hh, nh, replace = TRUE)
  }

  psu_df = unique(data.frame(stratum = stratum, psu = psu))
  psu_df$u_hj = rnorm(nrow(psu_df), mean = 0, sd = sigma_u)

  pop = data.frame(id = id, stratum = stratum, psu = psu)
  pop = merge(pop, psu_df, by = c("stratum", "psu"), all.x = TRUE, sort = FALSE)
  pop = pop[order(pop$id), ]

  SES = sample(1:3, N_pop, replace = TRUE, prob = c(0.3, 0.4, 0.3))
  X1  = rnorm(N_pop)
  X2  = rbinom(N_pop, 1, 0.5)

  beta_SES_stratum = matrix(
    c(-2, -0.5, 0,
      -1, -0.5, 0,
      -0.6, -0.2, 0,
      -0.3, -0.2, 0),
    nrow = H, byrow = TRUE
  )

  if (any(pop$stratum < 1 | pop$stratum > nrow(beta_SES_stratum))) {
    stop("gen_population: unexpected stratum labels")
  }
  beta_SES_unit = beta_SES_stratum[cbind(pop$stratum, SES)]

  eta = 0.1 + 0.5 * X1 + 0.8 * X2 + beta_SES_unit + pop$u_hj

  alpha = c(-1.0, -0.3, 0.4, 1.2)

  lp = sapply(alpha, function(a) plogis(a - eta))
  p_cat = cbind(lp[, 1],
                 lp[, 2] - lp[, 1],
                 lp[, 3] - lp[, 2],
                 lp[, 4] - lp[, 3],
                 1 - lp[, 4])
  Y = apply(p_cat, 1, function(p) sample(1:K, 1, prob = p))

  pop$SES = factor(SES)
  pop$X1 = X1
  pop$X2 = X2
  pop$Y  = factor(Y, ordered = TRUE)

  pop$u_hj = NULL
  pop
}

############################################################
# 2. Unequal-probability single-stage sampling
############################################################

sample_unequal = function(pop, n = 2000) {
  N = nrow(pop)
  # size measure correlated with health and SES
  size = exp(0.6 * as.numeric(pop$SES) + 0.2 * pop$X1)
  pi_i = n * size / sum(size)
  pi_i[pi_i > 0.99] = 0.99
  w_i  = 1 / pi_i

  idx = sample(seq_len(N), size = n, prob = pi_i)
  samp = pop[idx, ]
  samp$pi = pi_i[idx]
  samp$w  = w_i[idx]

  # For consistency with D-OWLB structure, treat each unit as its own PSU
  samp$stratum = 1L
  samp$psu = samp$id

  samp
}

############################################################
# 3. Methods: Naive, Weighted, S-WLB, D-OWLB (unit-level)
############################################################

fit_naive = function(samp, gamma = 0.73) {
  fit = polr(Y ~ SES + X1 + X2, data = samp, Hess = TRUE, method = "logistic")
  disparity_from_fit(fit, samp, group_var = "SES", gamma = gamma)
}

fit_weighted = function(samp, gamma = 0.73) {
  fit = polr(Y ~ SES + X1 + X2, data = samp, weights = w, Hess = TRUE, method = "logistic")
  disparity_from_fit(fit, samp, group_var = "SES", gamma = gamma)
}

# S-WLB: weights-only WLB
swlb_disp = function(samp, B = 400, gamma = 0.73) {
  n = nrow(samp)
  w_raw = samp$w
  w_scaled = n * w_raw / sum(w_raw)

  Glevels = levels(samp$SES)
  res = matrix(NA_real_, nrow = B, ncol = length(Glevels),
                dimnames = list(NULL, Glevels))

  for (b in 1:B) {
    Yw = rgamma(n, shape = 1, scale = w_scaled)
    g  = Yw / sum(Yw)

    fitb = polr(Y ~ SES + X1 + X2,
                 data = samp, weights = g,
                 Hess = FALSE, method = "logistic")
    res[b, ] = disparity_from_fit(fitb, samp, group_var = "SES", gamma = gamma)
  }
  res
}

# D-OWLB: unit-level Rao-Wu + WLB (each unit is its own PSU)
dowlb_unequal_disp = function(samp, B = 400, gamma = 0.73) {
  n = nrow(samp)
  if (n == 0) stop("dowlb_unequal_disp: empty samp")

  Glevels = levels(samp$SES)
  D_mat = matrix(NA_real_, nrow = B, ncol = length(Glevels),
                  dimnames = list(NULL, Glevels))

  # "PSU" table: here each unit is its own PSU
  psu_tab = data.frame(
    stratum = 1L,
    psu     = samp$psu,
    w_jh    = samp$w
  )

  m_h = nrow(psu_tab)   # number of "PSUs" in stratum 1
  M_h = m_h             # frame PSUs â‰ˆ sample PSUs

  for (b in 1:B) {
    # Stage 1: Rao-Wu at unit level (within single stratum)
    psu_h  = psu_tab$psu
    w_jh_orig = psu_tab$w_jh

    m_h0 = m_h
    M_h0 = M_h

    # select m_h_star units without replacement
    m_h_star = max(1L, m_h0 - 1L)
    sel = sample(psu_h, size = m_h_star, replace = FALSE)
    delta_jh = as.integer(psu_h %in% sel)

    f_h = m_h0 / M_h0
    lambda_h = sqrt(m_h_star * (1 - f_h) / (m_h0 - m_h_star))

    w_jh_star = w_jh_orig * (1 - lambda_h +
                                lambda_h * (m_h0 / m_h_star) * delta_jh)

    # replicate unit weights = original * (w_jh_star / w_jh)
    w_star = samp$w * (w_jh_star / w_jh_orig)

    # Normalize for WLB
    w_tilde = n * w_star / sum(w_star)

    V = rgamma(n, shape = 1, scale = w_tilde)
    g = V / sum(V)

    fitb = polr(Y ~ SES + X1 + X2,
                 data = samp, weights = g,
                 Hess = FALSE, method = "logistic")
    D_mat[b, ] = disparity_from_fit(fitb, samp,
                                     group_var = "SES",
                                     gamma = gamma)
  }

  D_mat
}

############################################################
# 4. Monte Carlo simulation (parallel on Windows)
############################################################

N_pop    = 1e5
H        = 4
K        = 5
n_sims   = 100
B_boot   = 400
gamma_D  = 0.73

pop = gen_population(N_pop = N_pop, H = H, K = K, sigma_u = 1.5)

# Finite-population truth for each SES group
true_D = sapply(levels(pop$SES), function(g) {
  sub = pop[pop$SES == g, ]
  tab = table(sub$Y)
  p_cat = as.numeric(tab) / sum(tab)
  cumprobs = cumsum(p_cat)[1:(length(p_cat) - 1)]
  apouey_disparity(cumprobs, gamma = gamma_D)
})
names(true_D) = levels(pop$SES)
groups = levels(pop$SES)

sim_one = function(rep_id) {
  message("Sim ", rep_id)
  samp = sample_unequal(pop, n = 2000)
  if (nrow(samp) == 0) stop("Empty sample in replicate ", rep_id)

  D_naive = fit_naive(samp, gamma = gamma_D)
  D_wt    = fit_weighted(samp, gamma = gamma_D)

  swlb_mat = swlb_disp(samp, B = B_boot, gamma = gamma_D)
  s_mean = colMeans(swlb_mat, na.rm = TRUE)
  s_var  = apply(swlb_mat, 2, var, na.rm = TRUE)
  s_L    = apply(swlb_mat, 2, quantile, probs = 0.025, na.rm = TRUE)
  s_U    = apply(swlb_mat, 2, quantile, probs = 0.975, na.rm = TRUE)

  dowlb_mat = dowlb_unequal_disp(samp, B = B_boot, gamma = gamma_D)
  d_mean = colMeans(dowlb_mat, na.rm = TRUE)
  d_var  = apply(dowlb_mat, 2, var, na.rm = TRUE)
  d_L    = apply(dowlb_mat, 2, quantile, probs = 0.025, na.rm = TRUE)
  d_U    = apply(dowlb_mat, 2, quantile, probs = 0.975, na.rm = TRUE)

  list(
    D_true  = true_D,
    D_naive = D_naive,
    D_wt    = D_wt,
    D_swlb  = s_mean,
    D_dowlb = d_mean,
    s_L = s_L, s_U = s_U, s_var = s_var,
    d_L = d_L, d_U = d_U, d_var = d_var
  )
}

# Parallel setup
n_cores = max(1L, parallel::detectCores() - 1L)
cl = makeCluster(n_cores)
registerDoParallel(cl)

export_objs = c("pop", "true_D", "sample_unequal",
                 "fit_naive", "fit_weighted",
                 "swlb_disp", "dowlb_unequal_disp",
                 "disparity_from_fit", "apouey_disparity", "gamma_D")

results = foreach(rep_id = seq_len(n_sims),
                   .packages = c("MASS", "survey"),
                   .export = export_objs,
                   .errorhandling = "stop") %dopar% {
  sim_one(rep_id)
}

stopCluster(cl)

############################################################
# 5. Summaries: bias, RMSE, coverage, variance ratios
############################################################

############################################################
# 5. Summaries: bias, RMSE, coverage, variance, MSE
############################################################

rest_tbl_unequal = data.frame(
  group = groups,
  rel_bias_naive    = NA,
  rel_bias_wt       = NA,
  rel_rmse_wt       = NA,
  rel_bias_swlb     = NA,
  rel_rmse_swlb     = NA,
  rel_bias_dowlb    = NA,
  rel_rmse_dowlb    = NA,
  cov_swlb          = NA,
  cov_dowlb         = NA,
  var_ratio_swlb    = NA,
  var_ratio_dowlb   = NA,
  # MSE for design-weighted estimator
  bias_wt           = NA,
  var_wt            = NA,
  mse_wt            = NA,
  bias2_over_mse_wt = NA,
  var_over_mse_wt   = NA,
  # NEW: MSE for S-WLB and D-OWLB point estimators
  mse_swlb          = NA,
  mse_dowlb         = NA,
  mse_ratio_swlb    = NA,
  mse_ratio_dowlb   = NA,
  stringsAsFactors  = FALSE
)

for (g in groups) {
  true_g     = sapply(results, function(x) x$D_true[g])
  hat_n_g    = sapply(results, function(x) x$D_naive[g])
  hat_w_g    = sapply(results, function(x) x$D_wt[g])
  hat_swlb_g = sapply(results, function(x) x$D_swlb[g])
  hat_dowlb_g= sapply(results, function(x) x$D_dowlb[g])

  mean_true  = mean(true_g, na.rm = TRUE)

  # --- Design-weighted estimator: MC bias, var, MSE ---
  mean_w  = mean(hat_w_g, na.rm = TRUE)
  bias_w  = mean_w - mean_true
  var_w   = var(hat_w_g, na.rm = TRUE)
  mse_w   = mean((hat_w_g - true_g)^2, na.rm = TRUE)

  # --- S-WLB and D-OWLB point estimators: MSE ---
  mse_s   = mean((hat_swlb_g - true_g)^2, na.rm = TRUE)
  mse_d   = mean((hat_dowlb_g - true_g)^2, na.rm = TRUE)

  # bootstrap variance averages
  s_var_g   = sapply(results, function(x) x$s_var[g])
  d_var_g   = sapply(results, function(x) x$d_var[g])
  mean_s_var = mean(s_var_g, na.rm = TRUE)
  mean_d_var = mean(d_var_g, na.rm = TRUE)

  # --- Relative bias (%), using true_g ---
  rest_tbl_unequal$rel_bias_naive[rest_tbl_unequal$group == g] =
    100 * mean(hat_n_g - true_g, na.rm = TRUE) / mean_true
  rest_tbl_unequal$rel_bias_wt[rest_tbl_unequal$group == g] =
    100 * (mean_w - mean_true) / mean_true
  rest_tbl_unequal$rel_bias_swlb[rest_tbl_unequal$group == g] =
    100 * (mean(hat_swlb_g, na.rm = TRUE) - mean_true) / mean_true
  rest_tbl_unequal$rel_bias_dowlb[rest_tbl_unequal$group == g] =
    100 * (mean(hat_dowlb_g, na.rm = TRUE) - mean_true) / mean_true

  # --- Relative RMSE (%): sqrt(MSE) scaled by mean_true ---
  rmse_w    = sqrt(mse_w)
  rmse_swlb = sqrt(mse_s)
  rmse_dowlb= sqrt(mse_d)

  rest_tbl_unequal$rel_rmse_wt[rest_tbl_unequal$group == g]    = 100 * rmse_w    / mean_true
  rest_tbl_unequal$rel_rmse_swlb[rest_tbl_unequal$group == g]  = 100 * rmse_swlb / mean_true
  rest_tbl_unequal$rel_rmse_dowlb[rest_tbl_unequal$group == g] = 100 * rmse_dowlb/ mean_true

  # --- Coverage ---
  s_Lg = sapply(results, function(x) x$s_L[g])
  s_Ug = sapply(results, function(x) x$s_U[g])
  d_Lg = sapply(results, function(x) x$d_L[g])
  d_Ug = sapply(results, function(x) x$d_U[g])

  rest_tbl_unequal$cov_swlb[rest_tbl_unequal$group == g] =
    mean(true_g >= s_Lg & true_g <= s_Ug, na.rm = TRUE)
  rest_tbl_unequal$cov_dowlb[rest_tbl_unequal$group == g] =
    mean(true_g >= d_Lg & true_g <= d_Ug, na.rm = TRUE)

  # --- Variance ratios (bootstrap / MC var of weighted estimator) ---
  rest_tbl_unequal$var_ratio_swlb[rest_tbl_unequal$group == g] = mean_s_var / var_w
  rest_tbl_unequal$var_ratio_dowlb[rest_tbl_unequal$group == g] = mean_d_var / var_w

  # --- Store MSE decomposition for design-weighted estimator ---
  rest_tbl_unequal$bias_wt[rest_tbl_unequal$group == g]  = bias_w
  rest_tbl_unequal$var_wt[rest_tbl_unequal$group == g]   = var_w
  rest_tbl_unequal$mse_wt[rest_tbl_unequal$group == g]   = mse_w
  if (mse_w > 0) {
    rest_tbl_unequal$bias2_over_mse_wt[rest_tbl_unequal$group == g] = (bias_w^2) / mse_w
    rest_tbl_unequal$var_over_mse_wt[rest_tbl_unequal$group == g]   = var_w / mse_w
  } else {
    rest_tbl_unequal$bias2_over_mse_wt[rest_tbl_unequal$group == g] = NA
    rest_tbl_unequal$var_over_mse_wt[rest_tbl_unequal$group == g]   = NA
  }

  # --- Store MSE for S-WLB and D-OWLB point estimators ---
  rest_tbl_unequal$mse_swlb[rest_tbl_unequal$group == g] = mse_s
  rest_tbl_unequal$mse_dowlb[rest_tbl_unequal$group == g] = mse_d
  if (mse_w > 0) {
    rest_tbl_unequal$mse_ratio_swlb[rest_tbl_unequal$group == g] = mse_s / mse_w
    rest_tbl_unequal$mse_ratio_dowlb[rest_tbl_unequal$group == g] = mse_d / mse_w
  } else {
    rest_tbl_unequal$mse_ratio_swlb[rest_tbl_unequal$group == g] = NA
    rest_tbl_unequal$mse_ratio_dowlb[rest_tbl_unequal$group == g] = NA
  }
}

print(rest_tbl_unequal)
write.csv(rest_tbl_unequal, "Results_DWOLB/comparison_unequal_probability.csv")
```